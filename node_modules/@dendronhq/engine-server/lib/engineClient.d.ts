import { BulkWriteNotesOpts, ConfigGetPayload, ConfigWriteOpts, DendronAPI, DendronError, DEngine, DEngineClient, DEngineDeleteSchemaResp, DEngineInitResp, DHookDict, DLink, DVault, EngineDeleteNoteResp, EngineDeleteOpts, EngineInfoResp, EngineUpdateNodesOptsV2, EngineWriteOptsV2, Event, FuseEngine, GetAnchorsRequest, GetDecorationsOpts, GetDecorationsPayload, GetLinksRequest, GetNoteAnchorsPayload, GetNoteBlocksOpts, GetNoteBlocksPayload, GetNoteLinksPayload, IntermediateDendronConfig, NoteChangeEntry, NoteProps, NotePropsByFnameDict, NotePropsByIdDict, Optional, QueryNotesOpts, RefreshNotesOpts, RenameNoteOpts, RenameNotePayload, RenderNoteOpts, RespV2, SchemaModuleDict, SchemaModuleProps, SchemaQueryResp, WriteNoteResp, FindNoteOpts, NotePropsMeta, UpdateNoteResp, RespV3, EngineEventEmitter } from "@dendronhq/common-all";
import { DLogger } from "@dendronhq/common-server";
import { FileStorage } from "./drivers/file/storev2";
import { HistoryService } from "./history";
declare type DendronEngineClientOpts = {
    vaults: DVault[];
    ws: string;
};
export declare class DendronEngineClient implements DEngineClient, EngineEventEmitter {
    private _onNoteChangedEmitter;
    notes: NotePropsByIdDict;
    noteFnames: NotePropsByFnameDict;
    wsRoot: string;
    schemas: SchemaModuleDict;
    links: DLink[];
    ws: string;
    fuseEngine: FuseEngine;
    api: DendronAPI;
    vaults: DVault[];
    configRoot: string;
    history?: HistoryService;
    logger: DLogger;
    store: FileStorage;
    config: IntermediateDendronConfig;
    hooks: DHookDict;
    static create({ port, vaults, ws, history, logger, }: {
        port: number | string;
        history?: HistoryService;
        logger?: DLogger;
    } & DendronEngineClientOpts): DendronEngineClient;
    static getPort({ wsRoot }: {
        wsRoot: string;
    }): number;
    constructor({ api, vaults, ws, history, logger, }: {
        api: DendronAPI;
        history?: HistoryService;
        logger?: DLogger;
    } & DendronEngineClientOpts);
    /**
     * Event that fires upon the changing of note state in the engine after a set
     * of NoteProps has been changed AND those changes have been reflected on the
     * engine side. Note creation, deletion, and updates are all fired from this
     * event.
     */
    get onEngineNoteStateChanged(): Event<NoteChangeEntry[]>;
    dispose(): void;
    /**
     * Load all nodes
     */
    init(): Promise<DEngineInitResp>;
    /**
     * See {@link DStore.getNote}
     */
    getNote(id: string): Promise<RespV3<NoteProps>>;
    /**
     * See {@link DStore.findNotes}
     */
    findNotes(opts: FindNoteOpts): Promise<NoteProps[]>;
    /**
     * See {@link DStore.findNotesMeta}
     * TODO: fix logic after engine refactor
     */
    findNotesMeta(opts: FindNoteOpts): Promise<NotePropsMeta[]>;
    bulkWriteNotes(opts: BulkWriteNotesOpts): Promise<import("@dendronhq/common-all").BulkWriteNoteResp>;
    deleteNote(id: string, opts?: EngineDeleteOpts): Promise<EngineDeleteNoteResp>;
    deleteSchema(id: string, opts?: EngineDeleteOpts): Promise<DEngineDeleteSchemaResp>;
    getConfig(): Promise<RespV2<ConfigGetPayload>>;
    info(): Promise<RespV2<EngineInfoResp>>;
    queryNote(opts: Parameters<DEngineClient["queryNotes"]>[0]): Promise<NoteProps[]>;
    queryNotes(opts: QueryNotesOpts): Promise<{
        data: NoteProps[];
        error: null;
    }>;
    queryNotesSync({ qs, originalQS, vault, }: {
        qs: string;
        originalQS: string;
        vault?: DVault;
    }): {
        error: null;
        data: NoteProps[];
    };
    renderNote(opts: RenderNoteOpts): Promise<{
        data: import("@dendronhq/common-all").RenderNotePayload;
        error: DendronError<import("@dendronhq/common-all").StatusCodes | undefined> | null;
    }>;
    refreshNotes(opts: RefreshNotesOpts): Promise<{
        error: null;
    }>;
    refreshNotesV2(notes: NoteChangeEntry[]): Promise<void>;
    refreshSchemas(smods: SchemaModuleProps[]): Promise<void>;
    /** Renames the note.
     *
     *  WARNING: When doing bulk operations. Do not invoke multiple requests to this
     *  command in parallel, wait for a single call to finish before requesting another call.
     *  Otherwise some race condition starts to cause intermittent failures.
     *  */
    renameNote(opts: RenameNoteOpts): Promise<RespV2<RenameNotePayload>>;
    sync(): Promise<DEngineInitResp>;
    updateNote(note: NoteProps, opts?: EngineUpdateNodesOptsV2): Promise<UpdateNoteResp>;
    writeNote(note: NoteProps, opts?: EngineWriteOptsV2): Promise<WriteNoteResp>;
    getSchema(id: string): Promise<RespV3<SchemaModuleProps>>;
    querySchema(qs: string): Promise<SchemaQueryResp>;
    updateSchema(schema: SchemaModuleProps): Promise<void>;
    writeConfig(opts: ConfigWriteOpts): ReturnType<DEngine["writeConfig"]>;
    writeSchema(schema: SchemaModuleProps): Promise<void>;
    getNoteBlocks({ id, filterByAnchorType, }: GetNoteBlocksOpts): Promise<GetNoteBlocksPayload>;
    getDecorations(opts: GetDecorationsOpts): Promise<GetDecorationsPayload>;
    getAnchors(opts: GetAnchorsRequest): Promise<GetNoteAnchorsPayload>;
    getLinks(opts: Optional<GetLinksRequest, "ws">): Promise<GetNoteLinksPayload>;
}
export {};
