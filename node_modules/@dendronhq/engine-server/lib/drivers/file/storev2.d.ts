import { BulkWriteNotesOpts, DendronCompositeError, IntermediateDendronConfig, DendronError, DEngineClient, DEngineDeleteSchemaResp, DEngineInitResp, DEngineInitSchemaResp, DLink, DNoteAnchorPositioned, DStore, DVault, EngineDeleteOpts, EngineUpdateNodesOptsV2, EngineWriteOptsV2, IDendronError, NoteChangeEntry, NoteProps, NotePropsByIdDict, NotesCacheEntryMap, RenameNoteOpts, RenameNotePayload, SchemaModuleDict, SchemaModuleProps, StoreDeleteNoteResp, WriteNoteResp, NoteChangeUpdateEntry, NotePropsByFnameDict, FindNoteOpts, RespV3 } from "@dendronhq/common-all";
import { DLogger } from "@dendronhq/common-server";
export declare class FileStorage implements DStore {
    vaults: DVault[];
    /**
     * Warning: currently this note dictionary contains backlink data that gets
     * populated upon initialization. However, the update note operations do not change
     * the backlink data in this dictionary hence it starts to contain stale backlink data.
     *  */
    notes: NotePropsByIdDict;
    noteFnames: NotePropsByFnameDict;
    schemas: SchemaModuleDict;
    logger: DLogger;
    links: DLink[];
    anchors: DNoteAnchorPositioned[];
    wsRoot: string;
    configRoot: string;
    config: IntermediateDendronConfig;
    private engine;
    constructor(props: {
        engine: DEngineClient;
        logger: DLogger;
    });
    init(): Promise<DEngineInitResp>;
    static createMalformedSchemaError(resp: DEngineInitSchemaResp): DendronError<import("@dendronhq/common-all").StatusCodes | undefined>;
    /**
     * See {@link DStore.getNote}
     */
    getNote(id: string): Promise<RespV3<NoteProps>>;
    /**
     * See {@link DStore.findNotes}
     */
    findNotes(opts: FindNoteOpts): Promise<NoteProps[]>;
    /**
     *
     * @param id id of note to be deleted
     * @returns
     */
    deleteNote(id: string, opts?: EngineDeleteOpts): Promise<StoreDeleteNoteResp>;
    deleteSchema(id: string, opts?: EngineDeleteOpts): Promise<DEngineDeleteSchemaResp>;
    initSchema(): Promise<DEngineInitSchemaResp>;
    _initSchema(vault: DVault): Promise<{
        data: SchemaModuleProps[];
        errors: any[];
    }>;
    initNotes(): Promise<{
        errors: IDendronError[];
    }>;
    /** Adds backlinks mutating 'allNotes' argument in place. */
    private _addBacklinks;
    private _addBacklinksImpl;
    _addLinkCandidates(allNotes: NoteProps[]): void[];
    _initNotes(vault: DVault): Promise<{
        notesById: NotePropsByIdDict;
        cacheUpdates: NotesCacheEntryMap;
        errors: IDendronError[];
    }>;
    bulkWriteNotes(opts: BulkWriteNotesOpts): Promise<{
        error: DendronCompositeError | null;
        data: ({
            note: NoteProps;
            status: "create" | "delete";
        } | NoteChangeUpdateEntry)[];
    }>;
    private referenceRangeParts;
    /**
     * Update the links inside this note that need to be updated for the rename from `oldLoc` to `newLoc`
     * Will update the note in place
     */
    private processNoteChangedByRename;
    renameNote(opts: RenameNoteOpts): Promise<RenameNotePayload>;
    /**
     * Update a note.
     *
     * If {@link newNode} is set, set the {@link NoteProps["parent"]} property and create stubs as necessary
     *
     * @param note
     * @param opts
     * @returns
     */
    updateNote(note: NoteProps, opts?: EngineUpdateNodesOptsV2): Promise<{
        error: any;
        data?: undefined;
    } | {
        data: NoteChangeEntry[];
        error: null;
    }>;
    updateSchema(schemaModule: SchemaModuleProps): Promise<void>;
    /**
     * Write a new note. Also take care of updating logic of parents and children if new note replaces an existing note that has a different id.
     * If the existing and new note have the same id, then do nothing.
     *
     * @param param0
     * @returns - Changed Entries
     */
    private _writeNewNote;
    writeNote(note: NoteProps, opts?: EngineWriteOptsV2): Promise<WriteNoteResp>;
    writeSchema(schemaModule: SchemaModuleProps): Promise<void>;
}
