"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEngine = exports.DendronEngineV2 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const _1 = require(".");
const config_1 = require("./config");
const storev2_1 = require("./drivers/file/storev2");
const unified_1 = require("@dendronhq/unified");
const hooks_1 = require("./topics/hooks");
function createRenderedCache(config, logger) {
    const ctx = "createRenderedCache";
    if (config.noCaching) {
        // If no caching flag is set we will use null caching object to avoid doing any
        // actual caching of rendered previews.
        logger.info({
            ctx,
            msg: `noCaching flag is true, will NOT use preview cache.`,
        });
        return new common_all_1.NullCache();
    }
    else {
        const maxPreviewsCached = common_all_1.ConfigUtils.getWorkspace(config).maxPreviewsCached;
        if (maxPreviewsCached && maxPreviewsCached > 0) {
            logger.info({
                ctx,
                msg: `Creating rendered preview cache set to hold maximum of '${config.maxPreviewsCached}' items.`,
            });
            return new common_all_1.LruCache({ maxItems: maxPreviewsCached });
        }
        else {
            // This is most likely to happen if the user were to set incorrect configuration
            // value for maxPreviewsCached, we don't want to crash initialization due to
            // not being able to cache previews. Hence we will log an error and not use
            // the preview cache.
            logger.error({
                ctx,
                msg: `Did not find valid maxPreviewsCached (value was '${maxPreviewsCached}')
        in configuration. When specified th value must be a number greater than 0. Using null cache.`,
            });
            return new common_all_1.NullCache();
        }
    }
}
class DendronEngineV2 {
    constructor(props) {
        this.wsRoot = props.wsRoot;
        this.configRoot = props.wsRoot;
        this.logger = props.logger;
        this.props = props;
        this.fuseEngine = new common_all_1.FuseEngine({
            fuzzThreshold: common_all_1.ConfigUtils.getLookup(props.config).note.fuzzThreshold,
        });
        this.links = [];
        this.config = props.config;
        this._vaults = props.vaults;
        this.store = props.createStore(this);
        const hooks = common_all_1.ConfigUtils.getWorkspace(props.config).hooks || {
            onCreate: [],
        };
        this.hooks = hooks;
        this.renderedCache = createRenderedCache(this.config, this.logger);
    }
    /**
     * @deprecated: Use {@link LinkUtils.findLinks}
     */
    async getLinks(opts) {
        const { type, note } = opts;
        return {
            data: unified_1.LinkUtils.findLinks({
                note,
                type,
                engine: this,
            }),
            error: null,
        };
    }
    /**
     * @deprecated: Use {@link AnchorUtils.findAnchors}
     */
    async getAnchors(opts) {
        return {
            data: unified_1.AnchorUtils.findAnchors({
                note: opts.note,
            }),
            error: null,
        };
    }
    static create({ wsRoot, logger }) {
        const LOGGER = logger || (0, common_server_1.createLogger)();
        const { error, data: config } = config_1.DConfig.readConfigAndApplyLocalOverrideSync(wsRoot);
        if (error) {
            LOGGER.error((0, common_all_1.stringifyError)(error));
        }
        return new DendronEngineV2({
            wsRoot,
            vaults: common_all_1.ConfigUtils.getVaults(config),
            forceNew: true,
            createStore: (engine) => new storev2_1.FileStorage({
                engine,
                logger: LOGGER,
            }),
            mode: "fuzzy",
            logger: LOGGER,
            config,
        });
    }
    static instance({ wsRoot }) {
        if (!DendronEngineV2._instance) {
            DendronEngineV2._instance = DendronEngineV2.create({ wsRoot });
        }
        return DendronEngineV2._instance;
    }
    /**
     * @deprecated
     * For accessing a specific note by id, see {@link DendronEngineV2.getNote}.
     * If you need all notes, avoid modifying any note as this will cause unintended changes on the store side
     */
    get notes() {
        return this.store.notes;
    }
    /**
     * @deprecated see {@link DendronEngineV2.findNotes}
     */
    get noteFnames() {
        return this.store.noteFnames;
    }
    /**
     * @deprecated
     * For accessing a specific schema by id, see {@link DendronEngineV2.getSchema}.
     * If you need all schemas, avoid modifying any schema as this will cause unintended changes on the store side
     */
    get schemas() {
        return this.store.schemas;
    }
    get vaults() {
        return this._vaults;
    }
    set notes(notes) {
        this.store.notes = notes;
    }
    set vaults(vaults) {
        this._vaults = vaults;
        this.store.vaults = vaults;
    }
    /**
     * Does not throw error but returns it
     */
    async init() {
        try {
            const { data, error: storeError } = await this.store.init();
            if (lodash_1.default.isUndefined(data)) {
                return {
                    error: common_all_1.DendronError.createFromStatus({
                        status: common_all_1.ERROR_STATUS.UNKNOWN,
                        severity: common_all_1.ERROR_SEVERITY.FATAL,
                    }),
                };
            }
            const { notes, schemas } = data;
            this.updateIndex("note");
            this.updateIndex("schema");
            const hookErrors = [];
            this.hooks.onCreate = this.hooks.onCreate.filter((hook) => {
                const { valid, error } = hooks_1.HookUtils.validateHook({
                    hook,
                    wsRoot: this.wsRoot,
                });
                if (!valid && error) {
                    this.logger.error({ msg: "bad hook", hook, error });
                    hookErrors.push(error);
                }
                return valid;
            });
            const allErrors = (lodash_1.default.isNull(storeError) ? [] : [storeError]).concat(hookErrors);
            let error;
            switch (lodash_1.default.size(allErrors)) {
                case 0: {
                    error = null;
                    break;
                }
                case 1: {
                    error = new common_all_1.DendronError(allErrors[0]);
                    break;
                }
                default:
                    error = new common_all_1.DendronCompositeError(allErrors);
            }
            this.logger.info({ ctx: "init:ext", error, storeError, hookErrors });
            return {
                error,
                data: {
                    notes,
                    schemas,
                    wsRoot: this.wsRoot,
                    vaults: this.vaults,
                    config: this.config,
                },
            };
        }
        catch (error) {
            const { message, stack, status } = error;
            const payload = { message, stack };
            return {
                error: common_all_1.DendronError.createPlainError({
                    payload,
                    message,
                    status,
                    severity: common_all_1.ERROR_SEVERITY.FATAL,
                }),
            };
        }
    }
    /**
     * See {@link DEngine.getNote}
     */
    async getNote(id) {
        return this.store.getNote(id);
    }
    /**
     * See {@link DEngine.findNotes}
     */
    async findNotes(opts) {
        return this.store.findNotes(opts);
    }
    /**
     * See {@link DEngine.findNotesMeta}
     */
    async findNotesMeta(opts) {
        return this.findNotes(opts);
    }
    async bulkWriteNotes(opts) {
        const changed = await this.store.bulkWriteNotes(opts);
        this.fuseEngine.replaceNotesIndex(this.notes);
        return changed;
    }
    async deleteNote(id, opts) {
        try {
            const note = this.notes[id];
            const changed = await this.store.deleteNote(id, opts);
            const noteChangeEntry = lodash_1.default.find(changed, (ent) => ent.note.id === id);
            if (noteChangeEntry.status === "delete") {
                await this.fuseEngine.removeNoteFromIndex(note);
            }
            return {
                data: changed,
                error: null,
            };
        }
        catch (err) {
            return {
                data: [],
                error: err,
            };
        }
    }
    async deleteSchema(id, opts) {
        try {
            const data = (await this.store.deleteSchema(id, opts));
            // deleted schema might affect notes
            await this.updateIndex("note");
            await this.updateIndex("schema");
            return data;
            // FIXM:E not performant
            // const smod = this.schemas[id];
            // await this.fuseEngine.removeSchemaFromIndex(smod);
            // return {
            //   data: undefined,
            //   error: null,
            // };
        }
        catch (err) {
            return {
                error: err,
            };
        }
    }
    async getConfig() {
        const cpath = config_1.DConfig.configPath(this.configRoot);
        const config = lodash_1.default.defaultsDeep((0, common_server_1.readYAML)(cpath), common_all_1.ConfigUtils.genDefaultConfig());
        return {
            error: null,
            data: config,
        };
    }
    async getSchema(id) {
        const maybeSchema = this.schemas[id];
        if (maybeSchema) {
            return { data: lodash_1.default.cloneDeep(maybeSchema) };
        }
        else {
            return {
                error: common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.CONTENT_NOT_FOUND,
                    message: `SchemaModuleProps not found for key ${id}.`,
                    severity: common_all_1.ERROR_SEVERITY.MINOR,
                }),
            };
        }
    }
    async info() {
        const version = common_server_1.NodeJSUtils.getVersionFromPkg();
        if (!version) {
            return {
                data: undefined,
                error: common_all_1.DendronError.createPlainError({
                    message: "Unable to read Dendron version",
                }),
            };
        }
        return {
            data: {
                version,
            },
            error: null,
        };
    }
    queryNotesSync({ qs, originalQS, }) {
        const items = this.fuseEngine.queryNote({ qs, originalQS });
        return {
            error: null,
            data: items.map((ent) => this.notes[ent.id]),
        };
    }
    async querySchema(queryString) {
        const ctx = "querySchema";
        let items = [];
        const results = await this.fuseEngine.querySchema({ qs: queryString });
        items = results.map((ent) => this.schemas[ent.id]);
        // if (queryString === "") {
        //   items = [this.schemas.root];
        // } else if (queryString === "*") {
        //   items = _.values(this.schemas);
        // } else {
        //   const results = this.schemaIndex.search(queryString);
        //   items = _.map(results, (resp) => this.schemas[resp.item.id]);
        // }
        this.logger.info({ ctx, msg: "exit" });
        return {
            error: null,
            data: items,
        };
    }
    async queryNotes(opts) {
        const ctx = "Engine:queryNotes";
        const { qs, vault, onlyDirectChildren, originalQS } = opts;
        // Need to ignore this because the engine stringifies this property, so the types are incorrect.
        // @ts-ignore
        if ((vault === null || vault === void 0 ? void 0 : vault.selfContained) === "true" || (vault === null || vault === void 0 ? void 0 : vault.selfContained) === "false")
            vault.selfContained = vault.selfContained === "true";
        const items = await this.fuseEngine.queryNote({
            qs,
            onlyDirectChildren,
            originalQS,
        });
        if (items.length === 0) {
            return { error: null, data: [] };
        }
        this.logger.info({ ctx, msg: "exit" });
        let notes = items.map((ent) => this.notes[ent.id]);
        if (!lodash_1.default.isUndefined(vault)) {
            notes = notes.filter((ent) => {
                return common_all_1.VaultUtils.isEqual(vault, ent.vault, this.wsRoot);
            });
        }
        return {
            error: null,
            data: notes,
        };
    }
    async renderNote({ id, note, flavor, dest, }) {
        const ctx = "DendronEngineV2:renderNote";
        // If provided, we render the given note entirely. Otherwise find the note in workspace.
        if (!note) {
            note = this.notes[id];
        }
        else {
            // `procRehype` needs the note to be in the engine, so we have to add it in case it's a dummy note
            this.store.updateNote(note);
        }
        // If note was not provided and we couldn't find it, we can't render.
        if (!note) {
            return common_all_1.ResponseUtil.createUnhappyResponse({
                error: common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.INVALID_STATE,
                    message: `${id} does not exist`,
                    code: common_all_1.StatusCodes.BAD_REQUEST,
                }),
            });
        }
        const cachedPreview = this.renderedCache.get(id);
        if (cachedPreview) {
            if (this.isCachedPreviewUpToDate(cachedPreview, note)) {
                this.logger.info({ ctx, id, msg: `Will use cached rendered preview.` });
                // Cached preview updated time is the same as note.updated time.
                // Hence we can skip re-rendering and return the cached version of preview.
                return common_all_1.ResponseUtil.createHappyResponse({ data: cachedPreview.data });
            }
        }
        this.logger.info({
            ctx,
            id,
            msg: `Did not find usable cached rendered preview. Starting to render.`,
        });
        const beforeRenderMillis = (0, common_all_1.milliseconds)();
        // Either we don't have have the cached preview or the version that is
        // cached has gotten stale, hence we will re-render the note and cache
        // the new value.
        let data;
        try {
            data = await this._renderNote({
                note,
                flavor: flavor || unified_1.ProcFlavor.PREVIEW,
                dest: dest || common_all_1.DendronASTDest.HTML,
            });
        }
        catch (error) {
            return common_all_1.ResponseUtil.createUnhappyResponse({
                error: new common_all_1.DendronError({
                    message: `Unable to render note ${note.fname} in ${common_all_1.VaultUtils.getName(note.vault)}`,
                    payload: error,
                }),
            });
        }
        this.renderedCache.set(id, {
            updated: note.updated,
            contentHash: note.contentHash,
            data,
        });
        const duration = (0, common_all_1.milliseconds)() - beforeRenderMillis;
        this.logger.info({ ctx, id, duration, msg: `Render preview finished.` });
        if (common_all_1.NoteUtils.isFileId(note.id)) {
            // Dummy note, we should remove it once we're done rendering
            this.store.deleteNote(note.id);
        }
        return common_all_1.ResponseUtil.createHappyResponse({ data });
    }
    isCachedPreviewUpToDate(cachedPreview, note) {
        // Most of the times the preview is going to be invalidated by users making changes to
        // the note itself, hence before going through the trouble of checking whether linked
        // reference notes have been updated we should do the super cheap check to see
        // whether the note itself has invalidated the preview.
        if (note.contentHash !== cachedPreview.contentHash) {
            return false;
        }
        // TODO: Add another check to see if backlinks have changed
        return (cachedPreview.updated >=
            common_all_1.NoteUtils.getLatestUpdateTimeOfPreviewNoteTree({
                rootNote: note,
                notes: this.notes,
            }));
    }
    async _renderNote({ note, flavor, dest, }) {
        let proc;
        if (dest === common_all_1.DendronASTDest.HTML) {
            proc = unified_1.MDUtilsV5.procRehypeFull({
                engine: this,
                fname: note.fname,
                vault: note.vault,
                config: this.config,
            }, { flavor });
        }
        else {
            proc = unified_1.MDUtilsV5.procRemarkFull({
                engine: this,
                fname: note.fname,
                vault: note.vault,
                dest,
            }, { flavor });
        }
        const payload = await proc.process(common_all_1.NoteUtils.serialize(note));
        const renderedNote = payload.toString();
        return renderedNote;
    }
    async sync() {
        throw Error("sync not implemented");
    }
    async refreshNotes(opts) {
        await this.refreshNotesV2(opts.notes);
        return { error: null };
    }
    async refreshNotesV2(notes) {
        await Promise.all(notes.map(async (ent) => {
            if (ent.status === "delete") {
                common_all_1.NoteDictsUtils.delete(ent.note, {
                    notesById: this.notes,
                    notesByFname: this.noteFnames,
                });
            }
            else {
                _1.EngineUtils.refreshNoteLinksAndAnchors({
                    note: ent.note,
                    engine: this,
                });
                this.store.updateNote(ent.note);
            }
        }));
        this.fuseEngine.replaceNotesIndex(this.notes);
    }
    async renameNote(opts) {
        try {
            const resp = await this.store.renameNote(opts);
            await this.refreshNotesV2(resp);
            return {
                error: null,
                data: resp,
            };
        }
        catch (err) {
            let error = err;
            if (err instanceof common_all_1.DendronError)
                error = (0, common_all_1.error2PlainObject)(err);
            if (lodash_1.default.isUndefined(err.message))
                err.message = "rename error";
            return { error };
        }
    }
    /**
     * @deprecated: Use {@link DEngine.writeNote}
     * See {@link FileStorageV2.updateNote}
     * @param note
     * @param opts
     * @returns
     */
    async updateNote(note, opts) {
        const ctx = "updateNote";
        this.logger.debug({ ctx, msg: "enter", note: common_all_1.NoteUtils.toNoteLoc(note) });
        const engine = this;
        try {
            _1.EngineUtils.refreshNoteLinksAndAnchors({
                note,
                engine,
            });
            this.logger.debug({ ctx, msg: "post:refreshed note links and anchors" });
            const out = this.store.updateNote(note, opts);
            this.logger.debug({ ctx, msg: "post:updateNote" });
            await this.updateIndex("note");
            this.logger.debug({ ctx, msg: "post:updateIndex" });
            return out;
        }
        catch (err) {
            this.logger.error({ ctx, msg: (0, common_all_1.error2PlainObject)(err) });
            throw err;
        }
    }
    async updateIndex(mode) {
        if (mode === "schema") {
            this.fuseEngine.replaceSchemaIndex(this.schemas);
        }
        else {
            this.fuseEngine.replaceNotesIndex(this.notes);
        }
    }
    async updateSchema(schemaModule) {
        const out = await this.store.updateSchema(schemaModule);
        await this.updateIndex("schema");
        return out;
    }
    async writeConfig(opts) {
        const { configRoot } = this;
        const cpath = config_1.DConfig.configPath(configRoot);
        (0, common_server_1.writeYAML)(cpath, opts.config);
        return {
            error: null,
        };
    }
    async addAccessTokensToPodConfig(opts) {
        const { path, tokens } = opts;
        const { accessToken, refreshToken, expirationTime } = tokens;
        let podConfig = (0, common_server_1.readYAML)(path);
        podConfig = {
            ...podConfig,
            accessToken,
            expirationTime,
        };
        if (!lodash_1.default.isUndefined(refreshToken)) {
            podConfig = {
                ...podConfig,
                refreshToken,
            };
        }
        (0, common_server_1.writeYAML)(path, podConfig);
    }
    async writeNote(note, opts) {
        _1.EngineUtils.refreshNoteLinksAndAnchors({
            note,
            engine: this,
        });
        const out = await this.store.writeNote(note, opts);
        this.fuseEngine.replaceNotesIndex(this.notes);
        return out;
    }
    async writeSchema(schema) {
        return this.store.writeSchema(schema);
    }
    async getNoteBlocks(opts) {
        const note = this.notes[opts.id];
        try {
            if (lodash_1.default.isUndefined(note))
                throw common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.INVALID_STATE,
                    message: `${opts.id} does not exist`,
                });
            const blocks = await unified_1.RemarkUtils.extractBlocks({
                note,
                engine: this,
            });
            if (opts.filterByAnchorType) {
                lodash_1.default.remove(blocks, (block) => { var _a; return ((_a = block.anchor) === null || _a === void 0 ? void 0 : _a.type) !== opts.filterByAnchorType; });
            }
            return { data: blocks, error: null };
        }
        catch (err) {
            return {
                error: err,
                data: undefined,
            };
        }
    }
    async getDecorations(opts) {
        const note = this.notes[opts.id];
        try {
            if (lodash_1.default.isUndefined(note))
                throw common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.INVALID_STATE,
                    message: `${opts.id} does not exist`,
                });
            // Very weirdly, these range numbers turn into strings when getting called in through the API.
            // Not sure if I'm missing something.
            opts.ranges = opts.ranges.map((item) => {
                return {
                    text: item.text,
                    range: (0, common_all_1.newRange)(lodash_1.default.toNumber(item.range.start.line), lodash_1.default.toNumber(item.range.start.character), lodash_1.default.toNumber(item.range.end.line), lodash_1.default.toNumber(item.range.end.character)),
                };
            });
            const { allDecorations: decorations, allDiagnostics: diagnostics, allErrors: errors, } = await (0, unified_1.runAllDecorators)({ ...opts, note, engine: this });
            let error = null;
            if (errors && errors.length > 1)
                error = new common_all_1.DendronCompositeError(errors);
            else if (errors && errors.length === 1)
                error = errors[0];
            return {
                data: {
                    decorations,
                    diagnostics,
                },
                error,
            };
        }
        catch (err) {
            return {
                error: err,
                data: undefined,
            };
        }
    }
}
exports.DendronEngineV2 = DendronEngineV2;
const createEngine = ({ wsRoot }) => {
    const engine = DendronEngineV2.create({ wsRoot });
    return engine;
};
exports.createEngine = createEngine;
//# sourceMappingURL=enginev2.js.map