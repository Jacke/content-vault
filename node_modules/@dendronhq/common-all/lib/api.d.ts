/// <reference types="node" />
import { AxiosInstance } from "axios";
import { BulkWriteNotesOpts, DEngineDeleteSchemaPayload, DEngineQuery, DNodeProps, DVault, EngineDeleteNotePayload, EngineDeleteOpts, EngineInfoResp, EngineUpdateNodesOptsV2, EngineWriteOptsV2, NoteProps, RenameNoteOpts, RenameNotePayload, RespV2, SchemaModuleProps, WriteNoteResp } from ".";
import { ThemeTarget, ThemeType } from "./constants";
import { DendronCompositeError, DendronError, IDendronError } from "./error";
import { BulkWriteNoteResp, DEngineInitPayload, GetDecorationsPayload, GetNoteAnchorsPayload, GetNoteBlocksPayload, GetNoteLinksPayload, IntermediateDendronConfig, NoteQueryResp, RenderNoteOpts, RenderNotePayload, UpdateNoteResp, VSRange } from "./types";
export declare type APIRequest<T> = {
    ws: string;
} & T;
export declare function createNoOpLogger(): {
    level: string;
    debug: (_msg: any) => void;
    info: (_msg: any) => void;
    error: (_msg: any) => void;
};
export declare type APIErrorType = "does_not_exist_error" | "not_authorized_error" | "unknown_error" | "invalid_request_error";
export interface IAPIErrorArgs {
    type: APIErrorType;
    message?: string;
    code?: number;
}
interface IRequestArgs {
    headers: any;
}
interface IAPIPayload {
    data?: null | any | any[];
    error: null | DendronError | DendronCompositeError;
}
interface IAPIOpts {
    endpoint: string;
    apiPath: string;
    _request: AxiosInstance;
    logger: any;
    statusHandlers: any;
    onAuth: (opts: IRequestArgs) => Promise<any>;
    onBuildHeaders: (opts: IRequestArgs) => Promise<any>;
    onError: (opts: {
        err: DendronError;
        body: any;
        resp: any;
        headers: any;
        qs: any;
        path: string;
        method: string;
    }) => any;
}
declare type IAPIConstructor = {
    endpoint: string;
    apiPath: string;
} & Partial<IAPIOpts>;
interface IDoRequestArgs {
    path: string;
    auth?: boolean;
    qs?: any;
    body?: any;
    method?: "get" | "post";
    json?: boolean;
}
/**
 @deprecated - use RespV2 instead
  */
declare type APIPayload<T = any> = {
    error: IDendronError | null;
    data?: T;
};
export declare type WorkspaceInitRequest = {
    uri: string;
    config: {
        vaults: DVault[];
    };
};
export declare type WorkspaceSyncRequest = WorkspaceRequest;
export declare type WorkspaceRequest = {
    ws: string;
};
export declare type EngineQueryRequest = DEngineQuery & {
    ws: string;
};
export declare type EngineRenameNoteRequest = RenameNoteOpts & {
    ws: string;
};
export declare type EngineUpdateNoteRequest = {
    ws: string;
} & {
    note: NoteProps;
    opts?: EngineUpdateNodesOptsV2;
};
export declare type EngineWriteRequest = {
    node: DNodeProps;
    opts?: EngineWriteOptsV2;
} & {
    ws: string;
};
export declare type EngineDeleteRequest = {
    id: string;
    opts?: EngineDeleteOpts;
} & {
    ws: string;
};
export declare type EngineBulkAddRequest = {
    opts: BulkWriteNotesOpts;
} & {
    ws: string;
};
export declare type EngineInfoRequest = WorkspaceRequest;
export declare type NoteQueryRequest = {
    qs: string;
    vault?: DVault;
} & Partial<WorkspaceRequest>;
export declare type GetNoteBlocksRequest = {
    id: string;
    filterByAnchorType?: "header" | "block";
} & WorkspaceRequest;
export declare type GetDecorationsRequest = {
    id: string;
    ranges: {
        range: VSRange;
        text: string;
    }[];
    text: string;
} & Partial<WorkspaceRequest>;
export declare type GetAnchorsRequest = {
    note: NoteProps;
};
export declare type GetLinksRequest = {
    note: NoteProps;
    /** regular is backlinks for wikilinks, hashtags, user tags etc., candidate is for backlink candidates */
    type: "regular" | "candidate";
} & WorkspaceRequest;
export declare type SchemaDeleteRequest = {
    id: string;
    opts?: EngineDeleteOpts;
} & Partial<WorkspaceRequest>;
export declare type SchemaReadRequest = {
    id: string;
} & Partial<WorkspaceRequest>;
export declare type SchemaQueryRequest = {
    qs: string;
} & Partial<WorkspaceRequest>;
export declare type SchemaWriteRequest = {
    schema: SchemaModuleProps;
} & WorkspaceRequest;
export declare type SchemaUpdateRequest = SchemaWriteRequest;
export declare type AssetGetRequest = {
    fpath: string;
} & WorkspaceRequest;
export declare type AssetGetThemeRequest = {
    themeTarget: ThemeTarget;
    themeType: ThemeType;
} & WorkspaceRequest;
export declare type InitializePayload = APIPayload<DEngineInitPayload>;
export declare type WorkspaceSyncPayload = InitializePayload;
export declare type WorkspaceListPayload = APIPayload<{
    workspaces: string[];
}>;
export declare type EngineQueryPayload = APIPayload<DNodeProps[]>;
export declare type EngineRenameNotePayload = APIPayload<RenameNotePayload>;
export declare type EngineDeletePayload = APIPayload<EngineDeleteNotePayload>;
export declare type SchemaDeletePayload = APIPayload<DEngineDeleteSchemaPayload>;
export declare type SchemaReadPayload = APIPayload<SchemaModuleProps>;
export declare type SchemaQueryPayload = APIPayload<SchemaModuleProps[]>;
export declare type SchemaWritePayload = APIPayload<string>;
export declare type SchemaUpdatePayload = APIPayload<void>;
export declare class APIUtils {
    static genUrlWithQS({ url, params }: {
        url: string;
        params: any;
    }): string;
    /** Generate a localhost url to this API.
     *
     * Warning! In VSCode, the generated URL won't work if the user has a remote
     * workspace. You'll need to use `vscode.env.asExternalUri` to make it remote.
     */
    static getLocalEndpoint(port: number): string;
}
declare abstract class API {
    opts: IAPIOpts;
    constructor(opts: IAPIConstructor);
    _log(msg: any, lvl?: "info" | "debug" | "error" | "fatal"): void;
    _createPayload(data: any): {
        error: null;
        data: any;
    };
    _doRequest({ auth, qs, path, body, method, json, }: IDoRequestArgs): Promise<import("axios").AxiosResponse<any>>;
    _makeRequest<T extends IAPIPayload>(args: IDoRequestArgs, payloadData?: T["data"]): Promise<T>;
    _makeRequestRaw(args: IDoRequestArgs): Promise<any>;
}
export declare class DendronAPI extends API {
    static getOrCreate(opts: IAPIConstructor): DendronAPI;
    static instance(): DendronAPI;
    assetGet(req: AssetGetRequest): Promise<DendronError | Buffer>;
    assetGetTheme(req: AssetGetThemeRequest): Promise<DendronError | Buffer>;
    configGet(req: WorkspaceRequest): Promise<APIPayload<IntermediateDendronConfig>>;
    configWrite(req: IntermediateDendronConfig & WorkspaceRequest): Promise<RespV2<void>>;
    workspaceInit(req: WorkspaceInitRequest): Promise<InitializePayload>;
    workspaceList(): Promise<WorkspaceListPayload>;
    workspaceSync(req: WorkspaceSyncRequest): Promise<InitializePayload>;
    engineBulkAdd(req: EngineBulkAddRequest): Promise<BulkWriteNoteResp>;
    engineDelete(req: EngineDeleteRequest): Promise<EngineDeletePayload>;
    engineInfo(): Promise<RespV2<EngineInfoResp>>;
    engineRenameNote(req: EngineRenameNoteRequest): Promise<EngineRenameNotePayload>;
    engineUpdateNote(req: EngineUpdateNoteRequest): Promise<UpdateNoteResp>;
    engineWrite(req: EngineWriteRequest): Promise<WriteNoteResp>;
    noteQuery(req: NoteQueryRequest): Promise<NoteQueryResp>;
    noteRender(req: APIRequest<RenderNoteOpts>): Promise<{
        data: RenderNotePayload;
        error: null | DendronError;
    }>;
    getNoteBlocks(req: GetNoteBlocksRequest): Promise<GetNoteBlocksPayload>;
    getDecorations(req: GetDecorationsRequest): Promise<GetDecorationsPayload>;
    getLinks(req: GetLinksRequest): Promise<GetNoteLinksPayload>;
    getAnchors(req: GetAnchorsRequest): Promise<GetNoteAnchorsPayload>;
    schemaDelete(req: SchemaDeleteRequest): Promise<SchemaDeletePayload>;
    schemaRead(req: SchemaReadRequest): Promise<SchemaReadPayload>;
    schemaQuery(req: SchemaQueryRequest): Promise<SchemaQueryPayload>;
    schemaWrite(req: SchemaWriteRequest): Promise<SchemaWritePayload>;
    schemaUpdate(req: SchemaUpdateRequest): Promise<SchemaUpdatePayload>;
}
export declare const DendronApiV2: typeof DendronAPI;
export {};
