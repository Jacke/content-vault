"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TreeUtils = exports.TreeViewItemLabelTypeEnum = exports.TreeMenuNodeIcon = void 0;
const lodash_1 = __importDefault(require("lodash"));
const __1 = require("..");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const vault_1 = require("../vault");
var TreeMenuNodeIcon;
(function (TreeMenuNodeIcon) {
    TreeMenuNodeIcon["bookOutlined"] = "bookOutlined";
    TreeMenuNodeIcon["numberOutlined"] = "numberOutlined";
    TreeMenuNodeIcon["plusOutlined"] = "plusOutlined";
})(TreeMenuNodeIcon = exports.TreeMenuNodeIcon || (exports.TreeMenuNodeIcon = {}));
var TreeViewItemLabelTypeEnum;
(function (TreeViewItemLabelTypeEnum) {
    TreeViewItemLabelTypeEnum["title"] = "title";
    TreeViewItemLabelTypeEnum["filename"] = "filename";
})(TreeViewItemLabelTypeEnum = exports.TreeViewItemLabelTypeEnum || (exports.TreeViewItemLabelTypeEnum = {}));
class TreeUtils {
    static generateTreeData(allNotes, domains) {
        // --- Calc
        const roots = domains
            .map((note) => {
            return TreeUtils.note2Tree({
                noteId: note.id,
                noteDict: allNotes,
            });
        })
            .filter((ent) => !lodash_1.default.isUndefined(ent));
        const child2parent = {};
        Object.entries(allNotes).forEach(([noteId, note]) => {
            child2parent[noteId] = note.parent;
        });
        return { roots, child2parent };
    }
    static note2Tree({ noteId, noteDict, }) {
        const note = noteDict[noteId];
        // return children of the current note
        const getChildren = () => {
            if (fm.nav_exclude_children || fm.has_collection) {
                return [];
            }
            const { data } = this.sortNotesAtLevel({
                noteIds: note.children,
                noteDict,
                reverse: fm.sort_order === "reverse",
            });
            return data
                .map((noteId) => TreeUtils.note2Tree({
                noteId,
                noteDict,
            }))
                .filter(utils_1.isNotUndefined);
        };
        if (lodash_1.default.isUndefined(note)) {
            return undefined;
        }
        let icon = null;
        if (note.schema) {
            icon = TreeMenuNodeIcon.bookOutlined;
        }
        else if (note.fname.toLowerCase() === constants_1.TAGS_HIERARCHY_BASE) {
            icon = TreeMenuNodeIcon.numberOutlined;
        }
        else if (note.stub) {
            icon = TreeMenuNodeIcon.plusOutlined;
        }
        const fm = utils_1.PublishUtils.getPublishFM(note);
        return {
            key: note.id,
            title: note.title,
            icon,
            hasTitleNumberOutlined: note.fname.startsWith(constants_1.TAGS_HIERARCHY),
            vaultName: vault_1.VaultUtils.getName(note.vault),
            navExclude: fm.nav_exclude || false,
            children: getChildren(),
        };
    }
    /**
     * Create tree starting from given root note. Use note's children properties to define TreeNode children relationship
     *
     * @param allNotes
     * @param rootNoteId
     * @returns
     */
    static createTreeFromEngine(allNotes, rootNoteId) {
        const note = allNotes[rootNoteId];
        if (note) {
            const children = note.children
                .filter((child) => child !== note.id)
                .sort((a, b) => a.localeCompare(b))
                .map((note) => this.createTreeFromEngine(allNotes, note));
            const fnames = note.fname.split(".");
            return { fname: fnames[fnames.length - 1], children };
        }
        else {
            throw new __1.DendronError({
                message: `No note found in engine for "${rootNoteId}"`,
            });
        }
    }
    /**
     * Create tree from list of file names. Use the delimiter "." to define TreeNode children relationship
     */
    static createTreeFromFileNames(fNames, rootNote) {
        const result = [];
        fNames.forEach((name) => {
            if (name !== rootNote) {
                name.split(".").reduce((object, fname) => {
                    let item = (object.children = object.children || []).find((q) => q.fname === fname);
                    if (!item) {
                        object.children.push((item = { fname, children: [] }));
                    }
                    return item;
                }, { children: result });
            }
        });
        return { fname: rootNote, children: result };
    }
    /**
     * Check if two trees are equal.
     * Two trees are equal if and only if fnames are equal and children tree nodes are equal
     */
    static validateTreeNodes(expectedTree, actualTree) {
        if (expectedTree.fname !== actualTree.fname) {
            return {
                error: new __1.DendronError({
                    message: `Fname differs. Expected: "${expectedTree.fname}". Actual "${actualTree.fname}"`,
                }),
            };
        }
        expectedTree.children.sort((a, b) => a.fname.localeCompare(b.fname));
        actualTree.children.sort((a, b) => a.fname.localeCompare(b.fname));
        if (expectedTree.children.length !== actualTree.children.length) {
            const expectedChildren = expectedTree.children.map((child) => child.fname);
            const actualChildren = actualTree.children.map((child) => child.fname);
            return {
                error: new __1.DendronError({
                    message: `Mismatch at ${expectedTree.fname}'s children. Expected: "${expectedChildren}". Actual "${actualChildren}"`,
                }),
            };
        }
        for (const [idx, value] of expectedTree.children.entries()) {
            const resp = this.validateTreeNodes(value, actualTree.children[idx]);
            if (resp.error) {
                return {
                    error: new __1.DendronError({
                        message: `Mismatch at ${expectedTree.fname}'s children. ${resp.error.message}.`,
                    }),
                };
            }
        }
        return { data: undefined };
    }
}
exports.TreeUtils = TreeUtils;
TreeUtils.getAllParents = ({ child2parent, noteId, }) => {
    const activeNoteIds = [noteId];
    let parent = child2parent[noteId];
    while (parent) {
        activeNoteIds.unshift(parent);
        parent = child2parent[parent];
    }
    return activeNoteIds;
};
TreeUtils.sortNotesAtLevel = ({ noteIds, noteDict, reverse, labelType, }) => {
    var _a;
    const unsafeNoteIds = [];
    const safeNoteIds = noteIds.filter((noteId) => {
        const props = lodash_1.default.get(noteDict, noteId);
        if (props === undefined) {
            unsafeNoteIds.push(noteId);
            return false;
        }
        else {
            return true;
        }
    });
    let error;
    if (unsafeNoteIds.length > 0) {
        error = new __1.DendronError({
            message: "Omitted sorting note ids not found in noteDict",
            payload: { omitted: unsafeNoteIds },
        });
    }
    const out = lodash_1.default.sortBy(safeNoteIds, 
    // Sort by nav order if set
    (noteId) => { var _a, _b; return (_b = (_a = noteDict[noteId]) === null || _a === void 0 ? void 0 : _a.custom) === null || _b === void 0 ? void 0 : _b.nav_order; }, 
    // Sort by label
    (noteId) => {
        var _a, _b, _c, _d;
        if (labelType) {
            return labelType === TreeViewItemLabelTypeEnum.filename
                ? (_b = lodash_1.default.last((_a = noteDict[noteId]) === null || _a === void 0 ? void 0 : _a.fname.split("."))) === null || _b === void 0 ? void 0 : _b.toLowerCase()
                : (_c = noteDict[noteId]) === null || _c === void 0 ? void 0 : _c.title.toLowerCase();
        }
        else {
            return (_d = noteDict[noteId]) === null || _d === void 0 ? void 0 : _d.title.toLowerCase();
        }
    }, 
    // If titles are identical, sort by last updated date
    (noteId) => { var _a; return (_a = noteDict[noteId]) === null || _a === void 0 ? void 0 : _a.updated; });
    // bubble down tags hierarchy if nav_order is not set
    const maybeTagsHierarchy = out.find((noteId) => noteDict[noteId].fname === constants_1.TAGS_HIERARCHY_BASE);
    if (maybeTagsHierarchy &&
        ((_a = noteDict[maybeTagsHierarchy].custom) === null || _a === void 0 ? void 0 : _a.nav_order) === undefined) {
        const idx = out.indexOf(maybeTagsHierarchy);
        out.splice(idx, 1);
        out.push(maybeTagsHierarchy);
    }
    if (reverse) {
        return { data: lodash_1.default.reverse(out), error };
    }
    return { data: out, error };
};
//# sourceMappingURL=treeUtil.js.map