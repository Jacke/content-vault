import { DendronError } from "..";
import { NotePropsByIdDict, NoteProps, RespV3 } from "../types";
export declare enum TreeMenuNodeIcon {
    bookOutlined = "bookOutlined",
    numberOutlined = "numberOutlined",
    plusOutlined = "plusOutlined"
}
export declare type TreeMenuNode = {
    key: string;
    title: string;
    icon: TreeMenuNodeIcon | null;
    hasTitleNumberOutlined: boolean;
    vaultName: string;
    navExclude: boolean;
    children?: TreeMenuNode[];
    contextValue?: string;
};
export declare type TreeMenu = {
    roots: TreeMenuNode[];
    child2parent: {
        [key: string]: string | null;
    };
};
export declare enum TreeViewItemLabelTypeEnum {
    title = "title",
    filename = "filename"
}
export declare type TreeNode = {
    fname: string;
    children: TreeNode[];
};
export declare class TreeUtils {
    static generateTreeData(allNotes: NotePropsByIdDict, domains: NoteProps[]): TreeMenu;
    static getAllParents: ({ child2parent, noteId, }: {
        child2parent: {
            [key: string]: string | null;
        };
        noteId: string;
    }) => string[];
    static note2Tree({ noteId, noteDict, }: {
        noteId: string;
        noteDict: NotePropsByIdDict;
    }): TreeMenuNode | undefined;
    static sortNotesAtLevel: ({ noteIds, noteDict, reverse, labelType, }: {
        noteIds: string[];
        noteDict: NotePropsByIdDict;
        reverse?: boolean | undefined;
        labelType?: TreeViewItemLabelTypeEnum | undefined;
    }) => {
        data: string[];
        error?: DendronError<import("http-status-codes/build/cjs/status-codes").StatusCodes | undefined> | undefined;
    };
    /**
     * Create tree starting from given root note. Use note's children properties to define TreeNode children relationship
     *
     * @param allNotes
     * @param rootNoteId
     * @returns
     */
    static createTreeFromEngine(allNotes: NotePropsByIdDict, rootNoteId: string): TreeNode;
    /**
     * Create tree from list of file names. Use the delimiter "." to define TreeNode children relationship
     */
    static createTreeFromFileNames(fNames: string[], rootNote: string): {
        fname: string;
        children: TreeNode[];
    };
    /**
     * Check if two trees are equal.
     * Two trees are equal if and only if fnames are equal and children tree nodes are equal
     */
    static validateTreeNodes(expectedTree: TreeNode, actualTree: TreeNode): RespV3<void>;
}
