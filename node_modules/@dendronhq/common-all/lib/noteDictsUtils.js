"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteFnameDictUtils = exports.NoteDictsUtils = void 0;
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("./utils");
const vault_1 = require("./vault");
/**
 * Utilities for working with NoteDicts. The reason NoteDicts is not a class is due to needing
 * to work with primitive objects with redux
 */
class NoteDictsUtils {
    /**
     * Construct NotePropsByIdDict from list of NoteProps
     *
     * @param notes Used to populate map
     * @returns NotePropsByIdDict
     */
    static createNotePropsByIdDict(notes) {
        const notesById = {};
        for (const note of notes) {
            notesById[note.id] = note;
        }
        return notesById;
    }
    /**
     * Find notes by fname. If vault is provided, filter results so that only notes with matching vault is returned
     * Return empty array if no match is found
     *
     * @param fname
     * @param noteDicts
     * @param vault If provided, use to filter results
     * @returns Array of NoteProps matching opts
     */
    static findByFname(fname, noteDicts, vault) {
        const { notesById, notesByFname } = noteDicts;
        const cleanedFname = (0, utils_1.cleanName)(fname);
        const ids = notesByFname[cleanedFname];
        if (!ids) {
            return [];
        }
        let notes = ids.map((id) => notesById[id]).filter(utils_1.isNotUndefined);
        if (vault) {
            notes = notes.filter((note) => vault_1.VaultUtils.isEqualV2(note.vault, vault));
        }
        return notes;
    }
    /**
     * Remove note from both notesById and notesByFname.
     * Returns true if note was deleted from both. False otherwise
     *
     * @param note note to delete
     * @param noteDicts
     * @return whether note was deleted
     */
    static delete(note, noteDicts) {
        const { notesById, notesByFname } = noteDicts;
        if (lodash_1.default.isUndefined(notesById[note.id])) {
            return false;
        }
        delete notesById[note.id];
        return NoteFnameDictUtils.delete(note, notesByFname);
    }
    /**
     * Add note to notesById and notesByFname.
     * If note id already exists, check to see if it corresponds to same note by fname.
     * If fname match, then we only need to update notesById. If fname doesn't match, remove old id from notesByFname first before updating both.
     *
     * Otherwise, if note id doesn't exist, add to both dictionaries
     *
     * @param note to add
     * @returns
     */
    static add(note, noteDicts) {
        const { notesById, notesByFname } = noteDicts;
        const maybeNote = notesById[note.id];
        if (maybeNote) {
            if ((0, utils_1.cleanName)(maybeNote.fname) === (0, utils_1.cleanName)(note.fname)) {
                notesById[note.id] = note;
                return;
            }
            else {
                // Remove old fname from fname dict
                NoteFnameDictUtils.delete(maybeNote, notesByFname);
            }
        }
        notesById[note.id] = note;
        NoteFnameDictUtils.add(note, notesByFname);
    }
}
exports.NoteDictsUtils = NoteDictsUtils;
/**
 * Utilities for working with NotePropsByFnameDict.
 */
class NoteFnameDictUtils {
    /**
     * Use NotePropsByIdDict to create a inverted index of {key -> value} where key = noteFname and value is list of ids corresponding to that fname
     *
     * @param notesById Used to populate map
     * @returns
     */
    static createNotePropsByFnameDict(notesById) {
        const notesByFname = {};
        lodash_1.default.values(notesById).forEach((note) => NoteFnameDictUtils.add(note, notesByFname));
        return notesByFname;
    }
    /**
     * Add note to notesByFname dictionary. If note fname exists, add note id to existing list of ids
     *
     * @param note to add
     * @param notesByFname dictionary to modify
     */
    static add(note, notesByFname) {
        const fname = (0, utils_1.cleanName)(note.fname);
        let ids = notesByFname[fname];
        if (lodash_1.default.isUndefined(ids))
            ids = [];
        ids.push(note.id);
        notesByFname[fname] = ids;
    }
    /**
     * Delete note from notesByFname dictionary. If note exists and it corresponds to last entry for that fname, delete fname entry
     * from dictionary as well
     * Returns true if note was deleted
     *
     * @param note to delete
     * @param notesByFname dictionary to modify
     * @returns whether note was deleted
     */
    static delete(note, notesByFname) {
        const fname = (0, utils_1.cleanName)(note.fname);
        const ids = notesByFname[fname];
        if (lodash_1.default.isUndefined(ids))
            return false;
        lodash_1.default.pull(ids, note.id);
        if (ids.length === 0) {
            delete notesByFname[fname];
        }
        else {
            notesByFname[fname] = ids;
        }
        return true;
    }
    /**
     * Merge two NotePropsByFnameDict into a single NotePropsByFnameDict
     * If key exists in both, merge values into a single array
     *
     * @return new merged NotePropsByFnameDict without modifying existing NotePropsByFnameDicts
     */
    static merge(fnameDictOne, fnameDictTwo) {
        const notesByFname = lodash_1.default.cloneDeep(fnameDictOne);
        lodash_1.default.entries(fnameDictTwo).forEach(([key, value]) => {
            // If same key exists, concat values
            if (notesByFname[key]) {
                notesByFname[key] = notesByFname[key].concat(value);
            }
            else {
                notesByFname[key] = value;
            }
        });
        return notesByFname;
    }
}
exports.NoteFnameDictUtils = NoteFnameDictUtils;
//# sourceMappingURL=noteDictsUtils.js.map