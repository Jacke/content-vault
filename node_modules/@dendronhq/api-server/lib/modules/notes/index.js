"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteController = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const core_1 = require("../../core");
const memoryStore_1 = require("../../store/memoryStore");
const utils_1 = require("../../utils");
class NoteController {
    static instance() {
        if (!NoteController.singleton) {
            NoteController.singleton = new NoteController();
        }
        return NoteController.singleton;
    }
    async delete({ ws, id, opts, }) {
        const engine = await (0, utils_1.getWSEngine)({ ws });
        try {
            const data = await engine.deleteNote(id, opts);
            return data;
        }
        catch (err) {
            return {
                error: new common_all_1.DendronError({ message: JSON.stringify(err) }),
                data: undefined,
            };
        }
    }
    async render({ ws, ...opts }) {
        const engine = await (0, utils_1.getWSEngine)({ ws });
        const data = await engine.renderNote(opts);
        return data;
    }
    async query({ ws, ...opts }) {
        const engine = ws
            ? await (0, utils_1.getWSEngine)({ ws })
            : memoryStore_1.MemoryStore.instance().getEngine();
        try {
            const data = await engine.queryNotes({ ...opts, originalQS: opts.qs });
            return data;
        }
        catch (err) {
            return {
                error: new common_all_1.DendronError({ message: JSON.stringify(err) }),
                data: [],
            };
        }
    }
    async info() {
        const ctx = "NoteController:info";
        (0, core_1.getLogger)().info({ ctx, msg: "enter" });
        try {
            const version = common_server_1.NodeJSUtils.getVersionFromPkg();
            if (!version) {
                return {
                    data: undefined,
                    error: common_all_1.DendronError.createPlainError({
                        message: "Unable to read the Dendron version",
                    }),
                };
            }
            return {
                data: {
                    version,
                },
                error: null,
            };
        }
        catch (err) {
            (0, core_1.getLogger)().error({ ctx, err });
            return {
                error: common_all_1.DendronError.createPlainError({
                    payload: err,
                    message: "unknown error",
                }),
                data: undefined,
            };
        }
    }
    async rename({ ws, ...opts }) {
        const engine = await (0, utils_1.getWSEngine)({ ws });
        const ctx = "NoteController:rename";
        try {
            (0, core_1.getLogger)().info({ ctx, msg: "enter" });
            const data = await engine.renameNote(opts);
            return data;
        }
        catch (err) {
            (0, core_1.getLogger)().error({ ctx, err });
            return {
                error: common_all_1.DendronError.createPlainError({
                    payload: err,
                    message: "unknown error",
                }),
                data: undefined,
            };
        }
    }
    async update({ ws, note, opts, }) {
        const engine = await (0, utils_1.getWSEngine)({ ws });
        try {
            return engine.updateNote(note, opts);
        }
        catch (err) {
            return {
                error: new common_all_1.DendronError({ message: JSON.stringify(err) }),
                data: undefined,
            };
        }
    }
}
exports.NoteController = NoteController;
//# sourceMappingURL=index.js.map