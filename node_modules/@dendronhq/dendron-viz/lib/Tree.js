"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTree = void 0;
/* eslint-disable react/no-array-index-key */
/* eslint-disable no-nested-ternary */
/* eslint-disable react/require-default-props */
const react_1 = __importStar(require("react"));
const countBy_1 = __importDefault(require("lodash/countBy"));
const maxBy_1 = __importDefault(require("lodash/maxBy"));
const entries_1 = __importDefault(require("lodash/entries"));
const uniq_1 = __importDefault(require("lodash/uniq"));
const flatten_1 = __importDefault(require("lodash/flatten"));
const CircleText_1 = require("./CircleText");
const utils_1 = require("./utils");
const loadModule = require("./loadModule");
//TODO: Set default colors for different file types. Adjust this so that different types of notes (ex. schemas or journals)
// can be color coded differently
const defaultColors = {};
const looseFilesId = "__structure_loose_file__";
const width = 1000;
const height = 1000;
const maxChildren = 9000;
const lastCommitAccessor = (d) => { var _a, _b; return new Date(((_b = (_a = d.commits) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.date) + "0"); };
const numberOfCommitsAccessor = (d) => { var _a; return ((_a = d === null || d === void 0 ? void 0 : d.commits) === null || _a === void 0 ? void 0 : _a.length) || 0; };
async function createTree() {
    const { extent, forceCollide, forceSimulation, forceX, forceY, hierarchy, pack, range, scaleLinear, scaleSqrt, timeFormat, } = await loadModule("d3");
    const Tree = ({ data, filesChanged = [], maxDepth = 9, colorEncoding = "type", customFileColors, }) => {
        const fileColors = {
            ...defaultColors,
            ...customFileColors,
        };
        const [selectedNodeId] = (0, react_1.useState)(null);
        const cachedPositions = (0, react_1.useRef)({});
        const cachedOrders = (0, react_1.useRef)({});
        const { colorScale, colorExtent } = (0, react_1.useMemo)(() => {
            if (!data)
                return { colorScale: () => { }, colorExtent: [0, 0] };
            const flattenTree = (d) => {
                return d.children ? (0, flatten_1.default)(d.children.map(flattenTree)) : d;
            };
            const items = flattenTree(data);
            // @ts-ignore
            const flatTree = colorEncoding === "last-change"
                ? items
                    .map(lastCommitAccessor)
                    .sort((a, b) => b - a)
                    .slice(0, -8)
                : items
                    .map(numberOfCommitsAccessor)
                    .sort((a, b) => b - a)
                    .slice(2, -2);
            const colorExtent = extent(flatTree);
            // const valueScale = scaleLog()
            //   .domain(colorExtent)
            //   .range([0, 1])
            //   .clamp(true);
            // const colorScale = scaleSequential((d) => interpolateBuPu(valueScale(d)));
            const colors = [
                "#f4f4f4",
                "#f4f4f4",
                "#f4f4f4",
                // @ts-ignore
                colorEncoding === "last-change" ? "#C7ECEE" : "#FEEAA7",
                // @ts-ignore
                colorEncoding === "number-of-changes" ? "#3C40C6" : "#823471",
            ];
            const colorScale = scaleLinear()
                .domain(range(0, colors.length).map((i) => +colorExtent[0] +
                ((colorExtent[1] - colorExtent[0]) * i) / (colors.length - 1)))
                .range(colors)
                .clamp(true);
            return { colorScale, colorExtent };
        }, [data]);
        const getColor = (d) => {
            var _a;
            if (colorEncoding === "type") {
                const isParent = d.children;
                if (isParent) {
                    const extensions = (0, countBy_1.default)(d.children, (c) => c.extension);
                    const mainExtension = (_a = (0, maxBy_1.default)((0, entries_1.default)(extensions), ([v]) => v)) === null || _a === void 0 ? void 0 : _a[0];
                    return fileColors[mainExtension] || "#CED6E0";
                }
                return fileColors[d.extension] || "#CED6E0";
            }
            else if (colorEncoding === "number-of-changes") {
                return colorScale(numberOfCommitsAccessor(d)) || "#f4f4f4";
            }
            else if (colorEncoding === "last-change") {
                return colorScale(lastCommitAccessor(d)) || "#f4f4f4";
            }
        };
        const packedData = (0, react_1.useMemo)(() => {
            if (!data)
                return [];
            const hierarchicalData = hierarchy(processChild(data, getColor, cachedOrders.current, 0, fileColors))
                .sum((d) => d.value)
                .sort((a, b) => {
                if (b.data.path.startsWith("src/fonts")) {
                    //   a.data.sortOrder,
                    //   b.data.sortOrder,
                    //   (b.data.sortOrder - a.data.sortOrder) ||
                    //     (b.data.name > a.data.name ? 1 : -1),
                    //   a,
                    //   b,
                    // );
                }
                return (b.data.sortOrder - a.data.sortOrder ||
                    (b.data.name > a.data.name ? 1 : -1));
            });
            const packedTree = pack()
                .size([width, height * 1.3]) // we'll reflow the tree to be more horizontal, but we want larger bubbles (.pack() sizes the bubbles to fit the space)
                .padding((d) => {
                if (d.depth <= 0)
                    return 0;
                const hasChildWithNoChildren = d.children.filter((d) => { var _a; return !((_a = d.children) === null || _a === void 0 ? void 0 : _a.length); }).length > 1;
                if (hasChildWithNoChildren)
                    return 5;
                return 13;
                // const hasChildren = !!d.children?.find((d) => d?.children?.length);
                // return hasChildren ? 60 : 8;
                // return [60, 20, 12][d.depth] || 5;
            })(hierarchicalData);
            packedTree.children = reflowSiblings(packedTree.children, cachedPositions.current, maxDepth);
            const children = packedTree.descendants();
            cachedOrders.current = {};
            cachedPositions.current = {};
            const saveCachedPositionForItem = (item) => {
                cachedOrders.current[item.data.path] = item.data.sortOrder;
                if (item.children) {
                    item.children.forEach(saveCachedPositionForItem);
                }
            };
            saveCachedPositionForItem(packedTree);
            children.forEach((d) => {
                cachedPositions.current[d.data.path] = [d.x, d.y];
            });
            return children.slice(0, maxChildren);
        }, [data, fileColors]);
        const selectedNode = selectedNodeId && packedData.find((d) => d.data.path === selectedNodeId);
        const fileTypes = (0, uniq_1.default)(packedData.map((d) => fileColors[d.data.extension] && d.data.extension))
            .sort()
            .filter(Boolean);
        return (react_1.default.createElement("svg", { width: width, height: height, style: {
                background: "white",
                fontFamily: "sans-serif",
                overflow: "visible",
            }, xmlns: "http://www.w3.org/2000/svg" },
            react_1.default.createElement("defs", null,
                react_1.default.createElement("filter", { id: "glow", x: "-50%", y: "-50%", width: "200%", height: "200%" },
                    react_1.default.createElement("feGaussianBlur", { stdDeviation: "4", result: "coloredBlur" }),
                    react_1.default.createElement("feMerge", null,
                        react_1.default.createElement("feMergeNode", { in: "coloredBlur" }),
                        react_1.default.createElement("feMergeNode", { in: "SourceGraphic" })))),
            packedData.map(({ x, y, r, depth, data, children }) => {
                if (depth <= 0)
                    return null;
                if (depth > maxDepth)
                    return null;
                const isParent = !!children;
                const runningR = r;
                // if (depth <= 1 && !children) runningR *= 3;
                if (data.path === looseFilesId)
                    return null;
                const isHighlighted = filesChanged.includes(data.path);
                const doHighlight = !!filesChanged.length;
                return (react_1.default.createElement("g", { key: data.path, style: {
                        fill: doHighlight
                            ? isHighlighted
                                ? "#FCE68A"
                                : "#ECEAEB"
                            : data.color,
                        transition: `transform ${isHighlighted ? "0.5s" : "0s"} ease-out, fill 0.1s ease-out`,
                        // opacity: doHighlight && !isHighlighted ? 0.6 : 1,
                    }, transform: `translate(${x}, ${y})` }, isParent ? (react_1.default.createElement(react_1.default.Fragment, null,
                    react_1.default.createElement("circle", { r: r, style: { transition: "all 0.5s ease-out" }, stroke: "#290819", strokeOpacity: "0.2", strokeWidth: "1", fill: "white" }))) : (react_1.default.createElement("circle", { style: {
                        filter: isHighlighted ? "url(#glow)" : undefined,
                        transition: "all 0.5s ease-out",
                    }, r: runningR, strokeWidth: selectedNodeId === data.path ? 3 : 0, stroke: "#374151" }))));
            }),
            packedData.map(({ x, y, r, depth, data, children }) => {
                if (depth <= 0)
                    return null;
                if (depth > maxDepth)
                    return null;
                const isParent = !!children && depth !== maxDepth;
                if (!isParent)
                    return null;
                if (data.path === looseFilesId)
                    return null;
                if (r < 16 && selectedNodeId !== data.path)
                    return null;
                if (data.label.length > r * 0.5)
                    return null;
                const label = (0, utils_1.truncateString)(data.label, r < 30 ? Math.floor(r / 2.7) + 3 : 100);
                const offsetR = r + 12 - depth * 4;
                const fontSize = 16 - depth;
                return (react_1.default.createElement("g", { key: data.path, style: { pointerEvents: "none", transition: "all 0.5s ease-out" }, transform: `translate(${x}, ${y})` },
                    react_1.default.createElement(CircleText_1.CircleText, { style: { fontSize, transition: "all 0.5s ease-out" }, r: Math.max(20, offsetR - 3), fill: "#374151", stroke: "white", strokeWidth: "6", rotate: depth * 1 - 0, text: label }),
                    react_1.default.createElement(CircleText_1.CircleText, { style: { fontSize, transition: "all 0.5s ease-out" }, fill: "#374151", rotate: depth * 1 - 0, r: Math.max(20, offsetR - 3), text: label })));
            }),
            packedData.map(({ x, y, r, depth, data, children }) => {
                if (depth <= 0)
                    return null;
                if (depth > maxDepth)
                    return null;
                const isParent = !!children;
                // if (depth <= 1 && !children) runningR *= 3;
                if (data.path === looseFilesId)
                    return null;
                const isHighlighted = filesChanged.includes(data.path);
                const doHighlight = !!filesChanged.length;
                if (isParent && !isHighlighted)
                    return null;
                if (selectedNodeId === data.path && !isHighlighted)
                    return null;
                if (!(isHighlighted || (!doHighlight && !selectedNode && r > 22))) {
                    return null;
                }
                const label = isHighlighted
                    ? data.label
                    : (0, utils_1.truncateString)(data.label, Math.floor(r / 4) + 3);
                return (react_1.default.createElement("g", { key: data.path, style: {
                        fill: doHighlight
                            ? isHighlighted
                                ? "#FCE68A"
                                : "#29081916"
                            : data.color,
                        transition: `transform ${isHighlighted ? "0.5s" : "0s"} ease-out`,
                    }, transform: `translate(${x}, ${y})` },
                    react_1.default.createElement("text", { style: {
                            pointerEvents: "none",
                            opacity: 0.9,
                            fontSize: "14px",
                            fontWeight: 500,
                            transition: "all 0.5s ease-out",
                        }, fill: "#4B5563", textAnchor: "middle", dominantBaseline: "middle", stroke: "white", strokeWidth: "3", strokeLinejoin: "round" }, label),
                    react_1.default.createElement("text", { style: {
                            pointerEvents: "none",
                            opacity: 1,
                            fontSize: "14px",
                            fontWeight: 500,
                            transition: "all 0.5s ease-out",
                        }, textAnchor: "middle", dominantBaseline: "middle" }, label),
                    react_1.default.createElement("text", { style: {
                            pointerEvents: "none",
                            opacity: 0.9,
                            fontSize: "14px",
                            fontWeight: 500,
                            mixBlendMode: "color-burn",
                            transition: "all 0.5s ease-out",
                        }, fill: "#110101", textAnchor: "middle", dominantBaseline: "middle" }, label)));
            }),
            !filesChanged.length && colorEncoding === "type" && (react_1.default.createElement(Legend, { fileTypes: fileTypes, fileColors: fileColors })),
            !filesChanged.length && colorEncoding !== "type" && (react_1.default.createElement(ColorLegend, { scale: colorScale, extent: colorExtent, colorEncoding: colorEncoding }))));
    };
    const formatD = (d) => typeof d === "number" ? d : timeFormat("%b %Y")(d);
    const ColorLegend = ({ scale, extent, colorEncoding, }) => {
        if (!scale || !scale.ticks)
            return null;
        const ticks = scale.ticks(10);
        return (react_1.default.createElement("g", { transform: `translate(${width - 160}, ${height - 90})` },
            react_1.default.createElement("text", { x: 50, y: "-5", fontSize: "10", textAnchor: "middle" }, colorEncoding === "number-of-changes"
                ? "Number of changes"
                : "Last change date"),
            react_1.default.createElement("linearGradient", { id: "gradient" }, ticks.map((tick, i) => {
                const color = scale(tick);
                return (react_1.default.createElement("stop", { offset: i / (ticks.length - 1), stopColor: color, key: i }));
            })),
            react_1.default.createElement("rect", { x: "0", width: "100", height: "13", fill: "url(#gradient)" }),
            extent.map((d, i) => (react_1.default.createElement("text", { key: i, x: i ? 100 : 0, y: "23", fontSize: "10", textAnchor: i ? "end" : "start" }, formatD(d))))));
    };
    const Legend = ({ fileTypes = [], fileColors, }) => {
        return (react_1.default.createElement("g", { transform: `translate(${width - 60}, ${height - fileTypes.length * 15 - 20})` },
            fileTypes.map((extension, i) => (react_1.default.createElement("g", { key: i, transform: `translate(0, ${i * 15})` },
                react_1.default.createElement("circle", { r: "5", fill: fileColors[extension] }),
                react_1.default.createElement("text", { x: "10", style: { fontSize: "14px", fontWeight: 300 }, dominantBaseline: "middle" },
                    ".",
                    extension)))),
            react_1.default.createElement("g", { fill: "#9CA3AF", style: {
                    fontWeight: 300,
                    fontStyle: "italic",
                    fontSize: 12,
                } }, "each dot sized by file size")));
    };
    const processChild = (child, getColor, cachedOrders, i = 0, fileColors) => {
        var _a;
        //TODO: Check if this produces any problem
        // if (!child) return;
        const isRoot = !child.path;
        let name = child.name;
        let path = child.path;
        let children = (_a = child === null || child === void 0 ? void 0 : child.children) === null || _a === void 0 ? void 0 : _a.map((c, i) => processChild(c, getColor, cachedOrders, i, fileColors));
        if ((children === null || children === void 0 ? void 0 : children.length) === 1) {
            name = `${name}/${children[0].name}`;
            path = children[0].path;
            children = children[0].children;
        }
        const pathWithoutExtension = path === null || path === void 0 ? void 0 : path.split(".").slice(0, -1).join(".");
        const extension = name === null || name === void 0 ? void 0 : name.split(".").slice(-1)[0];
        const hasExtension = !!fileColors[extension];
        if (isRoot && children) {
            const looseChildren = children === null || children === void 0 ? void 0 : children.filter((d) => { var _a; return !((_a = d.children) === null || _a === void 0 ? void 0 : _a.length); });
            children = [
                ...children === null || children === void 0 ? void 0 : children.filter((d) => { var _a; return (_a = d.children) === null || _a === void 0 ? void 0 : _a.length; }),
                {
                    name: looseFilesId,
                    path: looseFilesId,
                    size: 0,
                    children: looseChildren,
                },
            ];
        }
        const extendedChild = {
            ...child,
            name,
            path,
            label: name,
            extension,
            pathWithoutExtension,
            size: (["woff", "woff2", "ttf", "otf", "png", "jpg", "svg"].includes(extension)
                ? 100
                : Math.min(15000, hasExtension ? child.size : Math.min(child.size, 9000))) + i,
            value: (["woff", "woff2", "ttf", "otf", "png", "jpg", "svg"].includes(extension)
                ? 100
                : Math.min(15000, hasExtension ? child.size : Math.min(child.size, 9000))) + i,
            color: "#fff",
            children,
        };
        extendedChild.color = getColor(extendedChild);
        extendedChild.sortOrder = getSortOrder(extendedChild, cachedOrders, i);
        return extendedChild;
    };
    const reflowSiblings = (siblings, cachedPositions = {}, maxDepth, parentRadius, parentPosition) => {
        if (!siblings)
            return;
        const items = [
            ...siblings.map((d) => {
                var _a, _b;
                return {
                    ...d,
                    x: ((_a = cachedPositions[d.data.path]) === null || _a === void 0 ? void 0 : _a[0]) || d.x,
                    y: ((_b = cachedPositions[d.data.path]) === null || _b === void 0 ? void 0 : _b[1]) || d.y,
                    originalX: d.x,
                    originalY: d.y,
                };
            }),
        ];
        const paddingScale = scaleSqrt()
            .domain([maxDepth, 1])
            .range([3, 8])
            .clamp(true);
        const simulation = forceSimulation(items)
            .force("centerX", forceX(width / 2).strength(items[0].depth <= 2 ? 0.01 : 0))
            .force("centerY", forceY(height / 2).strength(items[0].depth <= 2 ? 0.01 : 0))
            .force("centerX2", forceX(parentPosition === null || parentPosition === void 0 ? void 0 : parentPosition[0]).strength(parentPosition ? 0.3 : 0))
            .force("centerY2", forceY(parentPosition === null || parentPosition === void 0 ? void 0 : parentPosition[1]).strength(parentPosition ? 0.8 : 0))
            .force("x", forceX((d) => { var _a; return ((_a = cachedPositions[d.data.path]) === null || _a === void 0 ? void 0 : _a[0]) || width / 2; }).strength((d) => { var _a; return ((_a = cachedPositions[d.data.path]) === null || _a === void 0 ? void 0 : _a[1]) ? 0.5 : (width / height) * 0.3; }))
            .force("y", forceY((d) => { var _a; return ((_a = cachedPositions[d.data.path]) === null || _a === void 0 ? void 0 : _a[1]) || height / 2; }).strength((d) => { var _a; return ((_a = cachedPositions[d.data.path]) === null || _a === void 0 ? void 0 : _a[0]) ? 0.5 : (height / width) * 0.3; }))
            .force("collide", forceCollide((d) => d.children ? d.r + paddingScale(d.depth) : d.r + 1.6)
            .iterations(8)
            .strength(1))
            .stop();
        for (let i = 0; i < 280; i += 1) {
            simulation.tick();
            items.forEach((d) => {
                var _a;
                d.x = (0, utils_1.keepBetween)(d.r, d.x, width - d.r);
                d.y = (0, utils_1.keepBetween)(d.r, d.y, height - d.r);
                if (parentPosition && parentRadius) {
                    // keep within radius
                    const containedPosition = (0, utils_1.keepCircleInsideCircle)(parentRadius, parentPosition, d.r, [d.x, d.y], !!((_a = d.children) === null || _a === void 0 ? void 0 : _a.length));
                    d.x = containedPosition[0];
                    d.y = containedPosition[1];
                }
            });
        }
        // setTimeout(() => simulation.stop(), 100);
        const repositionChildren = (d, xDiff, yDiff) => {
            const newD = { ...d };
            newD.x += xDiff;
            newD.y += yDiff;
            if (newD.children) {
                newD.children = newD.children.map((c) => repositionChildren(c, xDiff, yDiff));
            }
            return newD;
        };
        for (const item of items) {
            const itemCachedPosition = cachedPositions[item.data.path] || [
                item.x,
                item.y,
            ];
            const itemPositionDiffFromCached = [
                item.x - itemCachedPosition[0],
                item.y - itemCachedPosition[1],
            ];
            if (item.children) {
                const repositionedCachedPositions = { ...cachedPositions };
                const itemReflowDiff = [
                    item.x - item.originalX,
                    item.y - item.originalY,
                ];
                item.children = item.children.map((child) => repositionChildren(child, itemReflowDiff[0], itemReflowDiff[1]));
                if (item.children.length > 4) {
                    if (item.depth > maxDepth)
                        return;
                    item.children.forEach((child) => {
                        // move cached positions with the parent
                        const childCachedPosition = repositionedCachedPositions[child.data.path];
                        if (childCachedPosition) {
                            repositionedCachedPositions[child.data.path] = [
                                childCachedPosition[0] + itemPositionDiffFromCached[0],
                                childCachedPosition[1] + itemPositionDiffFromCached[1],
                            ];
                        }
                        else {
                            // const diff = getPositionFromAngleAndDistance(100, item.r);
                            repositionedCachedPositions[child.data.path] = [child.x, child.y];
                        }
                    });
                    item.children = reflowSiblings(item.children, repositionedCachedPositions, maxDepth, item.r, [item.x, item.y]);
                }
            }
        }
        return items;
    };
    const getSortOrder = (item, cachedOrders, i = 0) => {
        var _a, _b, _c;
        if (cachedOrders[item.path])
            return cachedOrders[item.path];
        if (cachedOrders[(_c = (_b = (_a = item.path) === null || _a === void 0 ? void 0 : _a.split("/")) === null || _b === void 0 ? void 0 : _b.slice(0, -1)) === null || _c === void 0 ? void 0 : _c.join("/")]) {
            return -100000000;
        }
        if (item.name === "public")
            return -1000000;
        // if (item.depth <= 1 && !item.children) {
        //   // item.value *= 0.33;
        //   return item.value  * 100;
        // }
        // if (item.depth <= 1) return -10;
        return item.value + -i;
        // return b.value - a.value;
    };
    return Tree;
}
exports.createTree = createTree;
//# sourceMappingURL=Tree.js.map