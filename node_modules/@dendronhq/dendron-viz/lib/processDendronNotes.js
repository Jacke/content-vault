"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.processDir = void 0;
const common_all_1 = require("@dendronhq/common-all");
const nodePath = __importStar(require("path"));
const shouldExcludePath_1 = require("./shouldExcludePath");
function isDir(note) {
    return note.children.length !== 0;
}
const processDir = async ({ rootPath = "", engine, vault, excludedPaths = [], excludedGlobs = [], }) => {
    /* Get absolute paths to files to be excluded from visualization */
    const foldersToIgnore = [".git", ...excludedPaths];
    const fullPathFoldersToIgnore = new Set(foldersToIgnore.map((d) => nodePath.join(rootPath, d)));
    /* Given a file name, get corresponding Dendron note */
    async function getNote(fname) {
        const note = await engine.findNotes({ fname, vault });
        if (note === undefined) {
            throw new Error(`Issue trying to find the note ${fname}`);
        }
        return note[0];
    }
    /* Given a note, get its child notes */
    function getChildren(note) {
        return note.children.map((id) => engine.notes[id]);
    }
    /* Given a note, get file stats needed for Tree React component */
    const getFileStats = async (note) => {
        const suffix = isDir(note) ? "" : ".md";
        const name = common_all_1.DNodeUtils.basename(note.fname);
        const size = note.body.length;
        return {
            name,
            path: note.fname + suffix,
            size,
        };
    };
    /* Get file stats of the given note and its children */
    const addItemToTree = async (note) => {
        /* Check if a given note should be included in the visualization */
        const fullPath = nodePath.join(vault.fsPath, note.fname);
        if ((0, shouldExcludePath_1.shouldExcludePath)(fullPath, fullPathFoldersToIgnore, excludedGlobs))
            return null;
        const stats = await getFileStats(note);
        /* Recursively process child notes */
        const notes = getChildren(note);
        const children = [];
        for (const cnote of notes) {
            // eslint-disable-next-line no-await-in-loop
            const stats = await addItemToTree(cnote);
            if (stats)
                children.push(stats);
        }
        return { ...stats, children };
    };
    /* Get the root note */
    const note = await getNote("root");
    /* Recursively traverse all notes and get file stats needed for Tree React component */
    const tree = await addItemToTree(note);
    /* If file stats of the root note cannot be obtained, throw an error */
    if (tree === null) {
        throw Error("Error: Issue processing workspace. Check if --wsRoot is set correctly.`");
    }
    return tree;
};
exports.processDir = processDir;
//# sourceMappingURL=processDendronNotes.js.map